
# TODO: Configs should be build-specific, not environment specific

import ClangReflect


include_paths = [
    "../../sdk/llvm/llvm/include",
    "../../sdk/llvm/build/include",
    "../../sdk/llvm/llvm/tools/clang/include",
    "../../sdk/llvm/build/tools/clang/include",
    "src",
    "inc",
]


libs = [
    "clangParse.lib",
    "clangSema.lib",
    "clangAnalysis.lib",
    "clangAST.lib",
    "clangFrontend.lib",
    "clangLex.lib",
    "clangBasic.lib",
    "LLVMSupport.lib",
    "LLVMCore.lib",
    "LLVMMC.lib",
    "advapi32.lib",
    "shell32.lib"
]


lib_paths_debug = [
    "../../sdk/llvm/build/lib/debug"
]


lib_paths_release = [
    "../../sdk/llvm/build/lib/release"
]


defines = [
    "_SCL_SECURE_NO_WARNINGS",
    "_CRT_SECURE_NO_WARNINGS"
]


# These are to allow clang/llvm to compile without hogging the output window
disabled_warnings = [
    4146,                   # unary minus operator applied to unsigned type, result still unsigned
    4624,                   # 'clang::Preprocessor::MacroInfoChain' : destructor could not be generated because a base class destructor is inaccessible
    4800,                   # 'clang::NestedNameSpecifier *const ' : forcing value to bool 'true' or 'false' (performance warning)
    4355,                   # 'this' : used in base member initializer list
    4291,                   # 'void *operator new(size_t,void *) throw()' : no matching operator delete found; memory will not be freed if initialization throws an exception
    4244,                   # 'return' : conversion from 'uint64_t' to 'unsigned int', possible loss of data
]


def SetCPPOptions(name, crt_type):
    opts = env.Configs[name].CPPOptions
    opts.IncludePaths = include_paths
    opts.DisabledWarnings = disabled_warnings
    opts.Defines += defines
    opts.CRTType = crt_type
    opts.UpdateCommandLine()

def SetLinkOptions(name, lib_paths):
    opts = env.Configs[name].LinkOptions
    opts.LibPaths = lib_paths
    opts.Subsystem = MSVCPlatform.VCSubsystem.CONSOLE
    opts.UpdateCommandLine()


SetCPPOptions("debug", MSVCPlatform.VCCRTType.MT_DEBUG_DLL)
SetLinkOptions("debug", lib_paths_debug)

SetCPPOptions("release", MSVCPlatform.VCCRTType.MT_DLL)
SetLinkOptions("release", lib_paths_release)


# Build the core library
crcore_cpp_files = Glob("src/ClangReflectCore", "*.cpp")
crcore_hpp_files = Glob("src/ClangReflectCore", "*.h")
crcore_obj_files = [ env.CPPFile(file) for file in crcore_cpp_files ]
crcore_lib = env.Lib("crcore.lib", crcore_obj_files)
env.Build(crcore_lib, "crcore")


# Build the scanner
crscan_cpp_files = Glob("src/ClangReflectScan", "*.cpp")
crscan_hpp_files = Glob("src/ClangReflectScan", "*.h")
crscan_lib_files = [ env.NewFile(file) for file in libs ]
crscan_obj_files = [ env.CPPFile(file) for file in crscan_cpp_files ]
crscan_exe = env.Link("crscan.exe", crscan_obj_files, crscan_lib_files + [ crcore_lib ])
env.Build(crscan_exe, "crscan")


# Build the merger
crmerge_cpp_files = Glob("src/ClangReflectMerge", "*.cpp")
crmerge_hpp_files = Glob("src/ClangReflectMerge", "*.h")
crmerge_obj_files = [ env.CPPFile(file) for file in crmerge_cpp_files ]
crmerge_exe = env.Link("crmerge.exe", crmerge_obj_files, [ crcore_lib ])
env.Build(crmerge_exe, "crmerge")


# Build the exporter
crexport_cpp_files = Glob("src/ClangReflectExport", "*.cpp")
crexport_hpp_files = Glob("src/ClangReflectExport", "*.h")
crexport_obj_files = [ env.CPPFile(file) for file in crexport_cpp_files ]
crexport_exe = env.Link("crexport.exe", crexport_obj_files, [ crcore_lib ])
env.Build(crexport_exe, "crexport")


# Build the C++ API
crcpp_cpp_files = Glob("src/ClangReflectCpp", "*.cpp")
crcpp_hpp_files = Glob("src/ClangReflectCpp", "*.h")
crcpp_api_files = Glob("inc", "*.h")
crcpp_obj_files = [ env.CPPFile(file) for file in crcpp_cpp_files ]
crcpp_lib = env.Lib("crcpp.lib", crcpp_obj_files)
env.Build(crcpp_lib, "crcpp")


# Build the test code with the generated crscan
# TODO: Probably going to have to flatten the graph before visiting
# test_obj_files is traversed twice below!
crtest_cpp_files = Glob("src/ClangReflectTest", "*.cpp")
crtest_obj_files = [ env.CPPFile(file) for file in crtest_cpp_files ]
crtest_cvs_files = [ ClangReflect.CppScan(file) for file in crtest_obj_files ]
crtest_db_file = ClangReflect.Merge("ClangReflectTest.csv", crtest_cvs_files)
env.Build(crtest_db_file, "crtest")


# Generate MSVC project files
VCGenerateProjectFile(env, "src/ClangReflectCore/ClangReflectCore", crcore_cpp_files + crcore_hpp_files, crcore_lib, "crcore")
VCGenerateProjectFile(env, "src/ClangReflectScan/ClangReflectScan", crscan_cpp_files + crscan_hpp_files, crscan_exe, "crscan")
VCGenerateProjectFile(env, "src/ClangReflectMerge/ClangReflectMerge", crmerge_cpp_files + crmerge_hpp_files, crmerge_exe, "crmerge")
VCGenerateProjectFile(env, "src/ClangReflectExport/ClangReflectExport", crexport_cpp_files + crexport_hpp_files, crexport_exe, "crexport")
VCGenerateProjectFile(env, "src/ClangReflectCpp/ClangReflectCpp", crcpp_cpp_files + crcpp_hpp_files + crcpp_api_files, crcpp_lib, "crcpp", [ ("..\\..\\inc", "Public API") ])
VCGenerateSolutionFile(env, "ClangReflect", [
    "src/ClangReflectCore/ClangReflectCore",
    "src/ClangReflectScan/ClangReflectScan",
    "src/ClangReflectMerge/ClangReflectMerge",
    "src/ClangReflectExport/ClangReflectExport",
    "src/ClangReflectCpp/ClangReflectCpp",
    "src/ClangReflectTest/ClangReflectTest" ])
